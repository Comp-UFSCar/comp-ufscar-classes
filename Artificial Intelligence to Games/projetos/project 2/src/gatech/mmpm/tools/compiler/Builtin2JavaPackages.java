/* Copyright 2010 Santiago Ontanon and Ashwin Ram */

package gatech.mmpm.tools.compiler;

import gatech.mmpm.tools.expressionparser.BinaryOperatorNode;
import gatech.mmpm.tools.expressionparser.BooleanLiteralNode;
import gatech.mmpm.tools.expressionparser.ExpressionNode;
import gatech.mmpm.tools.expressionparser.ExpressionNodeVisitor;
import gatech.mmpm.tools.expressionparser.FloatLiteralNode;
import gatech.mmpm.tools.expressionparser.IdentifierAccessNode;
import gatech.mmpm.tools.expressionparser.IntegerLiteralNode;
import gatech.mmpm.tools.expressionparser.InvocationNode;
import gatech.mmpm.tools.expressionparser.StringLiteralNode;
import gatech.mmpm.tools.expressionparser.TernaryOperatorNode;

import gatech.mmpm.tools.parseddomain.*;

import java.util.Set;
import java.util.HashSet;

/**
 * Class to recollect the Java packages that are used by the
 * code generated by Builtin2Java for a builtin expression.
 * 
 * The packages are used by the .java generator to
 * add the import sentences in the top of each file. 
 * 
 * The class is programmed has a visitor over the
 * gatech.mmpm.tools.expressionparser classes. A set of
 * strings is kept in the object to store the
 * used packages names. The same object could be
 * reused with different expressions (for example
 * for PreCondition and PostCondition in Action), to avoid
 * repeated import's.
 * 
 * @author Pedro Pablo Gomez Martin
 * @date November, 2009
 */
public class Builtin2JavaPackages implements ExpressionNodeVisitor {

	public Builtin2JavaPackages(ParsedDomain domain) {

		_domain = domain;
		_packages = new HashSet<String>();

	} // Constructor
	
	//---------------------------------------------------

	public Object visit(BinaryOperatorNode node) {
		
		switch (node.getOperator()) {
			case ADD:
			case MINUS:
			case MULT:
			case DIV:
			case MOD:
				_packages.add("gatech.mmpm.sensor.composite.ArithmeticSensor");
				break;
			case LT:
			case GT:
			case LE:
			case GE:
				_packages.add("gatech.mmpm.sensor.composite.RelationalCondition");
				break;
			case EQ:
			case NE:
				_packages.add("gatech.mmpm.sensor.composite.EqualitySensor");
				break;
			case AND:
				_packages.add("gatech.mmpm.sensor.composite.AndCondition");
				break;
			case OR:
				_packages.add("gatech.mmpm.sensor.composite.OrCondition");
				break;
			default:
				throw new RuntimeException("Internal error");
		} // switch

		node.getLHS().accept(this);
		node.getRHS().accept(this);

		// Nothing to return.
		return null;

	} // visit(BinaryOperatorNode node)

	//---------------------------------------------------
	
	public Object visit(BooleanLiteralNode node) {

		if (node.getValue() == true)
			_packages.add("gatech.mmpm.sensor.constant.True");
		else
			_packages.add("gatech.mmpm.sensor.constant.False");

		return null;

	} // visit(BooleanLiteralNode)

	//---------------------------------------------------

	public Object visit(IntegerLiteralNode node) {

		_packages.add("gatech.mmpm.sensor.constant.ConstantInteger");
		return null;

	} // visit(IntegerLiteralNode)

	//---------------------------------------------------

	public Object visit(FloatLiteralNode node) {

		_packages.add("gatech.mmpm.sensor.constant.ConstantFloat");
		return null;

	} // visit(FloatLiteralNode)

	//---------------------------------------------------

	public Object visit(InvocationNode node) {

		boolean hasParameters = false;

		_packages.add("gatech.mmpm.sensor.composite.Invocation");

		if (_domain.getSensorSet().getMethod(node.getName()) != null &&
			_domain.getSensorSet().getMethod(node.getName()).isNative() ||
			_domain.getGoalSet().getMethod(node.getName()) != null &&
			_domain.getGoalSet().getMethod(node.getName()).isNative())
				_packages.add("gatech.mmpm.sensor.builtin." + node.getName());
		// TODO: if we had recursive sensors, then
		// we should take care of not importing
		// the own sensor class... 
		else if (_domain.getSensorSet().getMethod(node.getName()) != null)
			_packages.add(_domain.getSensorSet().getPackageName() + "." + node.getName());
		else if (_domain.getGoalSet().getMethod(node.getName()) != null)
			_packages.add(_domain.getGoalSet().getPackageName() + "." + node.getName());

		for (ExpressionNode p:node.getParameters()) {
			if (p != null) {
				hasParameters = true;
				p.accept(this);
			}
		}

		if (hasParameters)
			_packages.add("gatech.mmpm.util.Pair");

		return null;

	} // visit(InvocationNode)

	//---------------------------------------------------

	public Object visit(IdentifierAccessNode node) {

		_packages.add("gatech.mmpm.sensor.composite.GetContextValue");
		return null;
		
	} //  visit(IdentifierAccessNode)

	//---------------------------------------------------

	public Object visit(StringLiteralNode node) {

		_packages.add("gatech.mmpm.sensor.constant.ConstantString");
		return null;
		
	} // visit(StringLiteralNode)

	//---------------------------------------------------

	public Object visit(TernaryOperatorNode node) {

		_packages.add("gatech.mmpm.sensor.composite.Conditional");
		node.getCondition().accept(this);
		node.getYesCase().accept(this);
		node.getNoCase().accept(this);
		return null;
		
	} // visit(TernaryOperatorNode)
	
	//---------------------------------------------------
	
	public String getImportLines() {
		StringBuffer sb;
		sb = new StringBuffer();
		
		for (String p:_packages) {
			sb.append("import ");
			sb.append(p);
			sb.append(";\n");
		}
		
		return sb.toString();
		
	} // getImportLines
	
	//---------------------------------------------------

	protected ParsedDomain _domain;

	protected Set<String> _packages;
	
} // class Builtin2JavaPackages
