/* Copyright 2010 Santiago Ontanon and Ashwin Ram */

package gatech.mmpm.tools;


import gatech.mmpm.learningengine.AbstractMEExecutor;
import jargs.gnu.CmdLineParser;

import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Attribute;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;


/**
 * Application that handles the learning process. It receives
 * the name of the class that defines the game domain (subclass
 * of gatech.mmpm.IDomain), the name of the class that defines
 * the <em>learning engine</em> (subclass of
 * gatech.mmpm.learnereigne.IMETrainer) and a generic set of
 * parameters specific of that learning engine. These parameters
 * are attribute-value pairs. 
 * 
 * Standard input receives the traces in an XML file, and
 * standard output will receive the ME generated by the
 * concrete learning engine. This behaviour can be changed
 * using the -i and -o parameters.
 * 
 * The XML input format is:
 *
 * <pre>
 * &lt;MMPMTrainerData&gt;
 *    &lt;TracesToLearn&gt;
 *       &lt;TraceToLearn player="playerName"&gt;
 *          &lt;gametrace&gt;
 *             [ ... Trace serialization ... ]
 *          &lt;/gametrace&gt;
 *       &lt;/TraceToLearn&gt;
 *    &lt;/TracesToLearn&gt;
 * &lt;/MMPMTrainerData&gt;
 * </pre>
 * 
 *  Dependencies:
 *       - jargs library (http://jargs.sourceforge.net/)
 *       - jdom library (http://www.jdom.org/)
 * 
 * @author Pedro Pablo Gomez-Martin and David Llanso
 * @date August, 2009
 */
public class Trainer {


	/**
	 * Parses the XML input file, and fill the object attributes
	 * with the read information.
	 *  
	 * @param is Input stream where the XML can be reached.
	 * @param domain Game domain of the traces been parsed.
	 * In the future this param will be removed because this
	 * method will be responsible of building the domain.
	 * 
	 * @return True if the XML could be parsed. 
	 */
	// @SuppressWarnings is added because of the casts done in
	// List<Element>
	@SuppressWarnings("unchecked")
	protected boolean parseXML(java.io.InputStream is, gatech.mmpm.IDomain domain) {

		SAXBuilder builder = new SAXBuilder();
		Document document;
		try {
			document = builder.build(is);
			Element root = document.getRootElement(); // <MMPMTrainerData>
			if (root == null) {
				System.err.println("Trainer.parseXML: cannot get root element.");
				return false;
			}

			// TODO: domain!

			// Parse the traces.
			Element tracesElement = root.getChild("TracesToLearn");
			if (tracesElement == null) {
				System.err.println("Trainer.parseXML: cannot find \"TracesToLearn\" element.");
				return false;
			}

			List<Element> traceElementList = tracesElement.getChildren("TraceToLearn");
			List<Element> FileTraceElementList = tracesElement.getChildren("FileTraceToLearn");
			List<Element> traceElementList2 = tracesFromFiles(FileTraceElementList);
			
			if (traceElementList == null && traceElementList == null)
				return false;
			
			else if (traceElementList != null && traceElementList != null)
				traceElementList.addAll(traceElementList2);
			
			else if (traceElementList == null)
				traceElementList = traceElementList2;

			if (!parseTraces(traceElementList, domain))
				return false;
			
		} catch (JDOMException e) {
			e.printStackTrace();
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		
		return true;
		
	} // parseXML
	
	//--------------------------------------------------------
	
	List<Element> tracesFromFiles(List<Element> FileTraceElementList)
	{
		SAXBuilder builder = new SAXBuilder();
		java.io.InputStream inStream;
		List<Element> traceElementList = new ArrayList<Element>();
		for (Element e:FileTraceElementList)
		{
			String inputFileName = e.getText().trim();
			if (inputFileName != null) 
			{
				try {
					inStream = new java.io.FileInputStream(inputFileName);
				} catch (java.io.IOException ex) {
					System.err.println(inputFileName + " does not exists or could not be opened.");
					continue;
				}
				//Just in case it is a compressed file.
				try {
					if (inputFileName.endsWith(".zip")) {
						java.util.zip.ZipInputStream zi;
						zi = new java.util.zip.ZipInputStream(inStream);
						zi.getNextEntry();
						inStream = zi;
					}
				} catch (java.io.IOException ex) {
					continue;
				}
				
				Document document;
				Element root;
				try {
					document = builder.build(inStream);
					root = document.getRootElement(); // <gametrace>
					if (root == null)
						continue;
				} catch (Exception ex) {
                    ex.printStackTrace();
					continue;
				}
				Element trace = new Element("TraceToLearn");
				root = (Element)root.clone();
				root.detach();
				trace.addContent(root);
				trace.setAttribute(((Attribute)e.getAttribute("player").clone()).detach());
				traceElementList.add(trace);
			}
		}
		return traceElementList;
		
	} // tracesFromFiles
	
	//--------------------------------------------------------
	
	/**
	 * Parses a list of <tt>&lt;TraceToLearn&gt;</tt> nodes
	 * and fills the attributes of the object with the
	 * read information. 
	 * 
	 * @param traceElements XML elements with each
	 * <tt>&lt;TraceToLearn&gt;</tt> node.
	 * @param domain Game domain of the traces been parsed.
	 * 
	 * @return True if the elements could be parsed. 
	 */
	protected boolean parseTraces(List<?> traceElements, gatech.mmpm.IDomain domain) {
		
		for (Object o:traceElements) {
			Element e;
			e = (Element) o;
			Attribute playerNameAttr;
			playerNameAttr = e.getAttribute("player");
			if (playerNameAttr == null)
				return false;
			String playerName = playerNameAttr.getValue();
			Element traceElement;
			traceElement = e.getChild("gametrace");
			gatech.mmpm.Trace trace;
			trace = gatech.mmpm.tracer.TraceParser.parse(traceElement, domain);
			
			if (trace == null)
				return false;

			_playerNames.add(playerName);
			_traces.add(trace);

		} // for

		return true;
		
	} // parseTraces
	
	public static gatech.mmpm.Trace parseTraceFromFile(String inputFileName, gatech.mmpm.IDomain domain) {
		SAXBuilder builder = new SAXBuilder();
		java.io.InputStream inStream;
		try {
			inStream = new java.io.FileInputStream(inputFileName);
		} catch (java.io.IOException ex) {
			System.err.println(inputFileName + " does not exists or could not be opened.");
			ex.printStackTrace();
			return null;
		}
		//Just in case it is a compressed file.
		try {
			if (inputFileName.endsWith(".zip")) {
				java.util.zip.ZipInputStream zi;
				zi = new java.util.zip.ZipInputStream(inStream);
				zi.getNextEntry();
				inStream = zi;
			}
		} catch (java.io.IOException ex) {
			ex.printStackTrace();
			return null;
		}
		
		Document document;
		Element root;
		try {
			document = builder.build(inStream);
			root = document.getRootElement(); // <gametrace>
			if (root == null)
				return null;
		} catch (Exception ex) {
			ex.printStackTrace();
			return null;
		}
		Element traceElement = new Element("TraceToLearn");
		root = (Element)root.clone();
		root.detach();
		traceElement.addContent(root);

		traceElement = traceElement.getChild("gametrace");
		return gatech.mmpm.tracer.TraceParser.parse(traceElement, domain);
	}
	

	//--------------------------------------------------------

	public static void printUsage() {
		System.out.println("Trainer: uses a learning engine to train (create) a ME.");
		System.out.println();
		System.out.println("Usage: Learner -t trainerClass -g gameDomainClass -D attr=value ...");
		System.out.println();
		System.out.println("\t-t|--trainer: specify the Java class that contains the");
		System.out.println("\t              ME trainer. It must implements the ");
		System.out.println("\t              gatech.mmpm.learningengine.IMETrainer interface.");
		System.out.println();
		System.out.println("\t-g|--game:    specify the java class that contains the information");
		System.out.println("\t              about the game. It must implements the");
		System.out.println("\t              gatech.mmpm.IDomain interface.");
		System.out.println("\t-D name=value: specify an option to be sent to the trainer.");
		System.out.println("\t              It's up to it to understand this attr, value)");
		System.out.println("\t              pair.");
		System.out.println("\t-i|--input file:  specify the file name where traces will be read of.");
		System.out.println("\t                  If no one is specified, standard input will be used.");
		System.out.println("\t-o|--output file: specify the file name where write the ME. If no one");
		System.out.println("\t                  is specified, standard output will be used.");
		System.out.println();
		System.out.println("Standard input will be the source of the traces using a");
		System.out.println("specific XML format. Standard output will be the target for");
		System.out.println("the new created ME.");
		System.out.println();
		System.out.println("The program return 0 if the ME was correctly generated and");
		System.out.println("a different value in other case. Under this situation, ");
		System.out.println("standard output could have received some output that will be");
		System.out.println("invalid and should be discarded.");
		System.out.println();
		System.out.println("Notes:");
		System.out.println("\t- Traces MUST have been generated by the game which");
		System.out.println("\t  is modeled by the game domain (-d option)");
	}

	//--------------------------------------------------------

	/**
	 * Main program. You can consult the valid args executing
	 * the program or consulting the printUsage() code.
	 * 
	 * @param args Program parameters.
	 * 
	 * @return 0 if it works, and a different value in other
	 * case. This value should be send back to the operative system.
	 */
	public static AbstractMEExecutor realMain(String[] args) {
		
		CmdLineParser parser = new CmdLineParser();
		
		CmdLineParser.Option trainerOpt = parser.addStringOption('t', "trainer");
		CmdLineParser.Option gameOpt = parser.addStringOption('g', "game");
		CmdLineParser.Option helpOpt = parser.addBooleanOption('h', "help");
		CmdLineParser.Option propertyOpts = parser.addStringOption('D', "");
		CmdLineParser.Option inputOpt = parser.addStringOption('i', "input");
		CmdLineParser.Option outputOpt = parser.addStringOption('o', "output");
		
		try {
			parser.parse(args);
		} catch (CmdLineParser.OptionException e) {
			System.err.println(e.getMessage());
			printUsage();
			System.exit(1);
		}
        
		boolean help = (Boolean)parser.getOptionValue(helpOpt, false);
		if (help) {
			printUsage();
			System.exit(0);
		}
        
		String[] remainingOpts = parser.getRemainingArgs();
        
		if (remainingOpts.length > 1) {
            System.err.println("remainingOpts: ");
            for(String s:remainingOpts) System.err.println(s);
			printUsage();
			System.exit(1);
        }
        
		String trainerClassName;
		String gameDomainClassName;
        
		trainerClassName = (String)parser.getOptionValue(trainerOpt);
		gameDomainClassName = (String)parser.getOptionValue(gameOpt);

		if ((trainerClassName == null) ||
		    (gameDomainClassName == null)) {
            System.err.println("trainerClassName: " + trainerClassName);
            System.err.println("gameDomainClassName: " + gameDomainClassName);
			printUsage();
			System.exit(1);
		}
        
		Class<? extends gatech.mmpm.learningengine.IMETrainer> trainerClass;
		Class<? extends gatech.mmpm.IDomain> gameDomainClass;

		Class<gatech.mmpm.learningengine.IMETrainer> IMETrainerInterface;
		Class<gatech.mmpm.IDomain> IDomainInterface;
        
		Class<?> askedClass;		// Auxiliary classes 

		IMETrainerInterface = gatech.mmpm.learningengine.IMETrainer.class;
		IDomainInterface = gatech.mmpm.IDomain.class;
        
		// TODO: these classes should be loaded into the JVM
		// using a Security Domain that denies all permissions.
		try {
			askedClass = Class.forName(trainerClassName);
		} catch (java.lang.ClassNotFoundException e) {
			System.err.println(trainerClassName + " not found.");
			return null;
		}

		try {
			trainerClass = askedClass.asSubclass(IMETrainerInterface);
		} catch (java.lang.ClassCastException e) {
			System.err.print(trainerClassName + " does not implements ");
			System.err.println(IMETrainerInterface.getName());
			return null;
		}

		// TODO: these classes should be loaded into the JVM
		// using a Security Domain that denies all permissions.
		try {
			askedClass = Class.forName(gameDomainClassName);
		} catch (java.lang.ClassNotFoundException e) {
			System.err.println(gameDomainClassName + " not found.");
			return null;
		}

		try {
			gameDomainClass = askedClass.asSubclass(IDomainInterface);
		} catch (java.lang.ClassCastException e) {
			System.err.print(gameDomainClassName + " does not implements ");
			System.err.println(IDomainInterface.getName());
			return null;
		}

		// Analyze properties parameters and create the Properties
		// object.
		java.util.Vector<?> propStrings = parser.getOptionValues(propertyOpts);
		java.util.Properties properties = new java.util.Properties();
		for (Object prop:propStrings) {
			String current = (String) prop;
			// prop will be something like:
			// plan_learning=hierarchical
			// We must split the string using the '=' as separator.
			String[] splitStr = current.split("=", 2);
			if (splitStr.length == 1) {
				// Missing '='.
				System.err.println("Invalid -D" + current + " option.");
				return null;
			}
			properties.setProperty(splitStr[0], splitStr[1]);
		} // for

		gatech.mmpm.IDomain gameDomain;
		gatech.mmpm.learningengine.IMETrainer trainer;
        
		try {
			gameDomain = gameDomainClass.newInstance();
		}
		catch (java.lang.Exception e) {
			System.err.print(gameDomainClassName + " coult not be ");
			System.err.println("instantiated (is it abstract?");
			return null;
		}

		try {
			trainer = trainerClass.newInstance();
		}
		catch (java.lang.Exception e) {
			System.err.print(trainerClassName + " coult not be ");
			System.err.println("instantiated (is it abstract?");
			return null;
		}
        
		String inputFileName;
		String outputFileName;
		java.io.InputStream inStream;
		java.io.OutputStream outStream;
        
		inputFileName = (String)parser.getOptionValue(inputOpt);
		outputFileName = (String)parser.getOptionValue(outputOpt);

		if (inputFileName != null) {
			try {
				inStream = new java.io.FileInputStream(inputFileName);
			} catch (java.io.IOException ex) {
				System.err.println(inputFileName + " does not exists or could not be opened.");
				return null;
			}
			//Just in case it is a compressed file.
			try {
				if (inputFileName.endsWith(".zip")) {
					java.util.zip.ZipInputStream zi;
					zi = new java.util.zip.ZipInputStream(inStream);
					zi.getNextEntry();
					inStream = zi;
				}
			} catch (java.io.IOException ex) {
				// It's not a zip file.
			}
		}
		else
			inStream = System.in;
        
		if (outputFileName != null) {
			try {
				outStream = new java.io.FileOutputStream(outputFileName);
				if (outputFileName.endsWith(".zip")) {
					java.util.zip.ZipOutputStream zo;
					zo = new java.util.zip.ZipOutputStream(outStream);
					zo.putNextEntry(new java.util.zip.ZipEntry("me.xml"));
					outStream = zo;
				}
			} catch (java.io.IOException ex) {
				System.err.println(outputFileName + " could not be opened for writting.");
				return null;
			}
		}
		else
			outStream = System.out;
		
		Trainer t = new Trainer();

		// TODO: in the future, the gameDomain will be created in
		// the parseXML method itself (the last param will be
		// removed).

		if (!t.parseXML(inStream, gameDomain)) {
			System.err.print("Error while deserializing traces.");
			return null;
		}

		try {
			AbstractMEExecutor me = trainer.train(t._traces, t._playerNames, gameDomain, properties, outStream);
                        return me;
		} catch (Exception e) {
			e.printStackTrace();
			System.err.println(e.getMessage());
		}

		return null;

	} // realMain

	//--------------------------------------------------------

	/**
	 * Main program. You can consult the valid args executing
	 * the program or consulting the printUsage() code.
	 * 
	 * @param args Program parameters.
	 *
	 * @note This method just calls to realMain() and
	 * returns it result to the underlying operative system.
	 */
	public static void main(String[] args) {

            AbstractMEExecutor me = realMain(args);
            if (me==null) System.exit(-1);
            System.exit(0);
        
	} // main

	//--------------------------------------------------------
	
	/**
	 * Traces parsed from the XML file.
	 */
    private List<gatech.mmpm.Trace> _traces = new LinkedList<gatech.mmpm.Trace>();
    
	/**
	 * Player names parsed from the XML file. Each one will
	 * correspond with a trace from traces attribute.
	 */
    private List<String> _playerNames = new LinkedList<String>();
	
} // Trainer
